# Node.js 과재

### 1. JavaScript의 자료형과 JavaScript만의 특성은 무엇일까

#### 느슨한 타입(loosely typed)의 동적(dynamic) 언어

- 정적(static/strong type) 언어는 변수를 선언할 때 데이터의 타입, 즉 변수에 할당할 수 있는 값의 종류를 사전에 선언해야 한다. 변수의 타입을 변경할 수 없으며, 선언된 변수에 알맞은 값만 할당 가능하다. 프로그램 컴파일 시점에 타입 체크(알맞은 데이터 값이 할당되었는지를 검사하는 처리)를 수행한 후, 이를 통과하지 못하면 에러를 발생하고 프로그램의 실행을 막는다. 이러한 일관성을 강제해 안정적인 코드를 구현하고 런타임 에러(프로그램 실행 중 발생하는 에러)를 방지한다. C와 C++ 등의 언어가 대표적이다.

- 동적(Dynamic) 언어는 반대로 변수를 선언할 때 데이터의 타입을 따로 선언하지 않는다. 변수의 선언 이후에 값을 할당하는 시점에서 변수의 타입이 동적으로 결정되고, 이후에도 변수의 타입을 자유롭게 변경할 수 있다. 결론적으로, 동적 언어는 변수의 타입이 선언이 아닌 할당에 의해 결정(타입 추론, type inference)된다. 자바스크립트와 파이썬, 루비 등이 대표적이다.

#### JavaScript 형변환

- 자바스크립트의 형변환은 크게 암묵적 변환과 명시적 변환으로 구분된다. 암묵적 타입 변환이란 개발자의 의도와는 상관 없이 주변 코드의 문맥을 고려하여 컴퓨터가 데이터 타입을 강제적으로 진행하는 변환이다. 명시적 타입 변환이란 개발자의 의도에 따라 명시적으로 진행하는 타입 변환이다. 명시적 타입 변화는 타입 변경에 대한 개발자의 의도가 명확하게 드러나나, 암묵적 변환에는 의도가 드러나지 않는다. 그렇기 때문에 타입 변환 결과의 예측이 어렵다면 암묵적 변환 시 오류가 발생할 가능성이 높다.

#### ==, ===
- 느슨한 비교(==)는 변수의 값을 기준으로 서로 다른 두 변수를 비교한다.
- 엄격한 비교(===)는 서로 다른 두 변수의 값과 자료형을 모두 비교한다. 

```JavaScript
2 == "2" // 예상 결과: true
2 === "2" // 예상 결과: false 
```

#### 느슨한 타입(loosely typed)의 동적(dynamic) 언어의 문제점은 무엇이고 보완할 수 있는 방법에는 무엇이 있을지 생각해보세요.

- 느슨한 타입 언어의 가장 큰 문제점 중 하나는 컴파일링 과정을 통해 변수의 타입 에러 문제점이 드러나지 않은 상태에서, 프로그램 실행 도중 예상치 못한 타입 오류로 런타임 에러가 발생할 수 있다는 점이다.
- 이를 보완하기 위해
  - 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
  - 변수의 유효범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야한다.
  - 전역변수는 최대한 사용하지 않도록 한다.
  - 변수보다는 상수를 사용해 값의 변경을 억제한다.
  - 변수 이름은 변수의 목적이나 이름을 파악할 수 있도록 네이밍한다.

#### undefined와 null의 미세한 차이들을 비교해보세요.

- null과 undefined 모두 공통적으로 값이 존재하지 않는다는 것을 표현하는 데이터 타입이다. 이 둘의 차이점은 undefined의 경우에는 변수 선언 이후 아무 동작이 수행되지 않은 상태이고, null의 경우에는 프로그래머가 의도적으로 값이 존재하지 않다는 것을 명시한 것이다. null의 경우에는 프로그래머의 의도가 반영된 것이므로 메모리에서 해제되어 메모리 누수를 방지한다.

### 2. JavaScript 객체와 불변성

#### 기본형(원시형) 데이터와 참조형 데이터 타입[[참고링크](https://okayoon.tistory.com/entry/코어-자바스크립트-데이터-타입-기본형-타입Primitive-Type과-참조형-타입Reference-Type)]
- 데이터 타입(data type): 값의 종류, 자바스크립트의 모든 값은 데이터 타입을 가진다
- 기본형(원시형) 타입은 객체가 아닌 데이터 유형으로, 메모리상에 고정된 크기로 데이터를 보관하여 값 자체를 변경할 수 없다. 숫자, 불리언, 문자열, undefined, null, 심벌 타입으로 나뉜다. 
- 참조형(객체형) 타입은 값이 저장된 주소값을 할당하는 데이터 타입이다.

#### 불변 객체를 만드는 방법
- 불변 객체란 생성 이후 그 상태를 바꿀 수 없는 객체이다. 객체 안의 객체(중첩 객체)까지 변경이 불가능하도록 동결한다. 한번 할당하면 재 할당은 가능하지만 내부 데이터를 변경할 수 없다. 
- 불변 객체 생성을 위해서는 객체의 복사본을 새로 생성하고, 이후 객체 변경 방지와 관련한 메서드(seal, freezd 등)을 사용하여 객체의 변경을 금지하는 강도를 조정

#### 얕은 복사와 깊은 복사
- 얕은 복사(shallow copy)는 객체를 한 단계까지 복사하는 것을 말하고, 깊은 복사(deep copy)는 중첩되어 있는 객체까지 모두 복사하는 것을 말한다. 얕은 복사의 경우 값 자체가 아닌 주소 값을 복사하기 때문에 원본 객체에 변화를 주게 되면 얕은 복사를 한 객체에도 변화가 나타난다. 깊은 복사는 메모리 자체를 모두 복사하며, 복사된 객체는 기존 객체와 완전히 독립적인 메모리를 차지한다. 

### 3. 호이스팅과 TDZ

#### 스코프, 호이스팅, TDZ
- 스코프(scope): 식별자(변수/함수/클래스 이름 등)가 다른 코드에 의해서 참조될 수 있는 유효 범위. 
- 호이스팅(hoisting): 코드가 실행되기 전에 필요한 선언들을 모두 끌어올려서 코드 유호 범위의 최상단에서 선언하는 것
  - 자바스크립트 엔진은 소스 코드 실행 전 준비 단계에서 변수 선언을 비롯한 모든 선언문을 소스 코드에서 찾아내서 실행
  - 예) 변수 호이스팅: 변수 선언이 런타임(코드 순차 실행 단계) 이전에 동작
```JavaScript
console.log(score); 
var score;  // 결과는 참조 에러가 아니라 undefined가 출력됨
```
- TDZ: 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간. let 키워드로 선언된 변수의 경우에는 선언 단계와 초기화 단계가 분리됨. 

```javascript
// 런타임 이전에 선언 단계가 실행된다. 아직 변수가 초기화되지 않았다.
// 초기화 이전의 일시적 사각 지대에서는 변수를 참조할 수 없다.
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

#### 함수 선언문과 함수 표현식에서 호이스팅 방식의 차이
- 함수 선언문과 표현식의 차이점: 함수 선언문을 통해 정의할 경우 함수 호이스팅이, 함수 표현식을 할 경우 변수 호이스팅이 발생. 여기에서 함수의 생성 시점의 차이가 발생함.
  - 함수 호이스팅의 경우에는 런타임 이전에 선언문이 먼저 실행, 이미 함수 객체가 생성되고 각각의 식별자(함수 이름)에 할당까지 완료됨. 그래서 함수 선언문의 경우 호출 뒤에 코드가 있어도 실행이 가능. 그러나 함수 선언문의 경우에는 변수 선언문 방식을 따라가기 때문에 런타임 이전에 변수가 초기화되어 undefined가 할당, 이후 런타임 과정에서 변수를 재할당 받음

```javascript
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

#### let, const, var, function의 실행 원리
- var의 경우에는 변수의 선언과 초기화 단계가 동시에 진행
  - 변수의 선언: 변수 이름을 등록하고 자바스크립트 엔진에 변수의 존재를 알림
  - 초기화 단계: 값을 저장하기 위해 메모리 공간을 확보하고 최초로 값을 할당, 암묵적으로 undefined를 할당
  - 할당 단계: 초기화된 변수에 값을 할당하는 단계
- let, const, function의 경우에는 변수의 선언과 초기화 단계가 분리

#### 행 컨텍스트와 콜 스택
- 행 컨텍스트는 자바스크립트의 동작 원리를 형상화하고 구성하는 개념. 컨텍스트는 크게 전역과 함수, eval, 모듈 컨텍스트로 구문. 
- 콜 스택은 프로그램이 함수 호출을 추적할 때 사용하는 기능이며, 각 함수 콜당 하나씩의 스택들로 구성되어 있음.

#### 스코프 체인, 변수 은닉화
- 스코프 체인이란: 해당 코드의 스코프 안에 있는 변수들을 정의하는 객체들의 리스트. 객체 안에 객체들이 중첩되면서 계층적인 구조를 가짐.
- 변수 은닉화: 객체의 프로퍼티와 메서드를 하나로 묶는 캡슐화를 통해서 특정 프로퍼티나 메서드를 감추는 과정

### 4. 과제
- 콘솔에 찍힐 b 값을 예상해보고, 어디에서 선언된 “b”가 몇번째 라인에서 호출한 console.log에 찍혔는지, 왜 그런지 설명해보세요. 주석을 풀어보고 오류가 난다면 왜 오류가 나는 지 설명하고 오류를 수정해보세요.

- 문제 
```JavaScript
let b = 1;

function hi () {

const a = 1;    // 변수 a는 함수 hi 안에서만 스코프가 적용, 함수 바깥으로 코드를 빼야 함

let b = 100;

b++;

console.log(a,b);

}

//console.log(a);

console.log(b);

hi();

console.log(b);
```

- 해설
```JavaScript
let b = 1;
const a = 1;    // 변수 a는 함수 hi 안에서만 스코프가 적용, 함수 바깥으로 코드를 빼야 함

function hi () {


let b = 100;

b++;

console.log(a,b);

}

console.log(a); // 1 출력 from 변수 선언 위치의 a

hi(); // 1 101 출력 from 첫 번째 1은 변수 선언 위치의 a, 두 번째는 함수 안의 b

console.log(b); // 1 출력 from 변수 선언 위치의 a
```